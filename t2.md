# Linting plan

I want to add a new djangofmt_lint crate to implement linting.
I want to do a first minimal implementation which goal is to detect invalid values in method attribute of <form> nodes.

<form method=""> only allow get / post / dialog

I want to:

- create a new crate for this djangofmt_lint
- use miette::Diagnostic to encapsulate the whole lint diagnostic logic
- I want to work directly on top of the ast generated by markup_fmt in /home/thibaut/.cargo/git/checkouts/markup_fmt-18f14530f61d2ae6/fcdb744/markup_fmt/src/lib.rs:49
- I want to take inspiration from the ruff linter visitor pattern https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L2284-L2292

# Diagnostic API

Use https://github.com/zkat/miette

# Ast checking and traversal.

Take inspiration from ruff:

- [`check_ast`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L3290C13-L3290C23)
- [`visit_body`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L2284-L2292)
- [`analyse_suite`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/analyze/suite.rs#L9)
- [`visit_stmt`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L905)

Give me a detailed plan on how to implement this and ask me clarification question if needed.
Add your plan after this line.

---

# Implementation Plan for `djangofmt_lint`

## Overview

Create a new `djangofmt_lint` crate that:

1. Uses `miette::Diagnostic` for error reporting
2. Works on top of `markup_fmt`'s AST (`Root`, `Node`, `Element`, etc.)
3. Implements a visitor pattern (inline in `Checker`, no separate trait)
4. First rule: validate `<form method="">` attribute (only `get`, `post`, `dialog` allowed)
5. CLI: `djangofmt check` command (separate from format)
6. All rules always enabled, errors cause non-zero exit

---

## Required `markup_fmt` Exports

Please expose the following from your `markup_fmt` fork:

```rust
// In markup_fmt/src/lib.rs, add:
pub mod ast;
pub use parser::Parser;
```

The `ast` module contains: `Root`, `Node`, `NodeKind`, `Element`, `Attribute`, `NativeAttribute`, `JinjaBlock`, `JinjaTag`, `JinjaTagOrChildren`, etc.

---

## Phase 1: Crate Setup

### 1.1 Create crate structure

```
crates/djangofmt_lint/
├── Cargo.toml
└── src/
    ├── lib.rs           # Public API: check_ast(), LintDiagnostic
    ├── checker.rs       # Checker struct with visit_* methods
    └── rules/
        ├── mod.rs       # Rule registry
        └── form_method.rs  # E001: invalid form method
```

### 1.2 `Cargo.toml`

```toml
[package]
name = "djangofmt_lint"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true

[dependencies]
markup_fmt = { workspace = true }
miette = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
insta = { workspace = true }
```

---

## Phase 2: Diagnostic System (miette)

### 2.1 `LintDiagnostic` type

```rust
use miette::{Diagnostic, SourceSpan};

#[derive(Debug, Diagnostic, thiserror::Error)]
#[error("{message}")]
#[diagnostic(code(djangofmt::{code}))]
pub struct LintDiagnostic {
    pub code: &'static str,
    pub message: String,
    #[label("{label}")]
    pub span: SourceSpan,
    pub label: String,
    #[help]
    pub help: Option<String>,
}
```

---

## Phase 3: Checker with Inline Visitor

### 3.1 `Checker` struct with `visit_*` methods

```rust
use markup_fmt::ast::{Attribute, Element, JinjaBlock, JinjaTagOrChildren, Node, NodeKind, Root};

pub struct Checker<'a> {
    pub source: &'a str,
    diagnostics: Vec<LintDiagnostic>,
}

impl<'a> Checker<'a> {
    pub fn new(source: &'a str) -> Self {
        Self {
            source,
            diagnostics: Vec::new(),
        }
    }

    pub fn report(&mut self, diagnostic: LintDiagnostic) {
        self.diagnostics.push(diagnostic);
    }

    pub fn into_diagnostics(self) -> Vec<LintDiagnostic> {
        self.diagnostics
    }

    pub fn visit_root(&mut self, root: &Root<'_>) {
        for node in &root.children {
            self.visit_node(node);
        }
    }

    pub fn visit_node(&mut self, node: &Node<'_>) {
        match &node.kind {
            NodeKind::Element(element) => self.visit_element(element),
            NodeKind::JinjaBlock(block) => self.visit_jinja_block(block),
            // Other node types that contain children...
            _ => {}
        }
    }

    pub fn visit_element(&mut self, element: &Element<'_>) {
        // Run element-level rules
        rules::form_method::check(element, self);

        // Recurse into children
        for child in &element.children {
            self.visit_node(child);
        }
    }

    pub fn visit_jinja_block(&mut self, block: &JinjaBlock<'_, Node<'_>>) {
        for item in &block.body {
            if let JinjaTagOrChildren::Children(children) = item {
                for child in children {
                    self.visit_node(child);
                }
            }
        }
    }
}
```

---

## Phase 4: First Rule - Invalid Form Method

### 4.1 Rule: `E001` - Invalid form method

**File:** `src/rules/form_method.rs`

```rust
use markup_fmt::ast::{Attribute, Element, NativeAttribute};
use crate::{Checker, LintDiagnostic};

const VALID_METHODS: &[&str] = &["get", "post", "dialog"];

pub fn check(element: &Element<'_>, checker: &mut Checker<'_>) {
    if !element.tag_name.eq_ignore_ascii_case("form") {
        return;
    }

    for attr in &element.attrs {
        if let Attribute::Native(NativeAttribute { name, value, .. }) = attr {
            if name.eq_ignore_ascii_case("method") {
                if let Some((value_str, offset)) = value {
                    let normalized = value_str.to_ascii_lowercase();
                    if !VALID_METHODS.contains(&normalized.as_str()) {
                        checker.report(LintDiagnostic {
                            code: "E001",
                            message: format!(
                                "Invalid form method '{value_str}'. Expected one of: get, post, dialog"
                            ),
                            span: (*offset, value_str.len()).into(),
                            label: "invalid method".into(),
                            help: Some("Use 'get', 'post', or 'dialog'".into()),
                        });
                    }
                }
            }
        }
    }
}
```

### 4.2 `src/rules/mod.rs`

```rust
pub mod form_method;
```

---

## Phase 5: Public API

### 5.1 `src/lib.rs`

```rust
mod checker;
mod rules;

pub use checker::Checker;

use markup_fmt::ast::Root;
use miette::{Diagnostic, SourceSpan};

#[derive(Debug, Diagnostic, thiserror::Error)]
#[error("{message}")]
#[diagnostic(code(djangofmt::{code}))]
pub struct LintDiagnostic {
    pub code: &'static str,
    pub message: String,
    #[label("{label}")]
    pub span: SourceSpan,
    pub label: String,
    #[help]
    pub help: Option<String>,
}

/// Check the AST for lint errors.
pub fn check_ast(source: &str, ast: &Root<'_>) -> Vec<LintDiagnostic> {
    let mut checker = Checker::new(source);
    checker.visit_root(ast);
    checker.into_diagnostics()
}
```

---

## Phase 6: CLI Integration

### 6.1 Add `djangofmt check` command

In `djangofmt` crate, add a new command handler:

**File:** `src/commands/check.rs`

```rust
use markup_fmt::{Language, Parser};
use djangofmt_lint::{check_ast, LintDiagnostic};
use miette::{NamedSource, Report};

pub fn check(args: CheckArgs) -> Result<ExitStatus> {
    let mut has_errors = false;

    for file in &args.files {
        let source = std::fs::read_to_string(file)?;
        let mut parser = Parser::new(&source, Language::Jinja, vec![]);
        let ast = parser.parse_root()?;

        let diagnostics = check_ast(&source, &ast);

        for diag in diagnostics {
            has_errors = true;
            let report = Report::new(diag)
                .with_source_code(NamedSource::new(file.display().to_string(), source.clone()));
            eprintln!("{report:?}");
        }
    }

    if has_errors {
        Ok(ExitStatus::Failure)
    } else {
        Ok(ExitStatus::Success)
    }
}
```

---

## Phase 7: Tests with `cargo insta`

### 7.1 Test Pattern (fixture-based with miette output)

Tests use HTML fixture files with all cases in a single file. Snapshots capture the fancy miette diagnostic output.

**Directory structure:**

```
crates/djangofmt_lint/tests/
├── common.rs              # Shared insta settings
├── check/
│   ├── main.rs            # Test runner with glob pattern
│   └── form_method/
│       ├── form_method.html   # Fixture with all test cases
│       └── form_method.snap   # Miette output snapshot
```

**Test runner:** `tests/check/main.rs`

```rust
#[test]
fn check_snapshot() {
    glob!("**/*.html", |path| {
        let input = fs::read_to_string(path).unwrap();
        let output = run_check_test(path, &input);
        build_settings(path).bind(|| {
            let name = path.file_stem().unwrap().to_str().unwrap();
            assert_snapshot!(name, output);
        });
    });
}

fn render_diagnostics(diagnostics: &[LintDiagnostic]) -> String {
    let handler = GraphicalReportHandler::new_themed(GraphicalTheme::unicode_nocolor());
    // ... render each diagnostic
}
```

**Fixture file:** `tests/check/form_method/form_method.html`

- Contains valid cases (no errors), invalid cases (errors), and interpolation cases (skipped)
- All cases in one file for easy review

### 7.2 Key behaviors

- **Interpolation skipped**: `method="{{ var }}"` or `method="{% if %}..."` are not checked
- **Case insensitive**: `GET`, `get`, `Get` all valid
- **Miette output**: Fancy error display with source context, line numbers, and help text

---

## Summary

| Decision         | Choice                                            |
| ---------------- | ------------------------------------------------- |
| AST access       | `pub mod ast` + `pub mod parser` exposed          |
| Offset semantics | Relative to source string start ✓                 |
| Rule config      | All rules always enabled                          |
| CLI command      | `djangofmt check` (separate from format)          |
| Severity         | Errors (non-zero exit code)                       |
| Visitor pattern  | Inline `visit_*` methods in `Checker`             |
| Testing          | Fixture-based HTML files, miette output snapshots |
| Interpolation    | Skipped (dynamic values not checked)              |

---

# Phase 2: Markuplint HTML Spec Integration

## Goal

Automate attribute validation rules by integrating the [markuplint HTML spec](https://github.com/markuplint/markuplint/tree/dev/packages/%40markuplint/html-spec) database. This enables rules like:

- **Invalid attribute values** (e.g., `<form method="put">`)
- **Unknown attributes** on elements
- **Deprecated attributes**
- **Required attributes** missing

## The Problem

Markuplint's `index.json` is ~48k lines containing:

- Element definitions (tag name, allowed attributes, content model)
- Global attributes (`#HTMLGlobalAttrs`, `#ARIAAttrs`, `#GlobalEventAttrs`)
- Attribute type definitions (enums, URLs, etc.)
- ARIA role specifications

**Runtime JSON parsing is too slow** for a fast linter. We need compile-time static data.

---

## Architecture: Compile-Time PHF Maps

### Overview

```
┌─────────────────┐     build.rs      ┌──────────────────────┐
│  index.json     │ ───────────────▶  │  generated_specs.rs  │
│  (markuplint)   │   parse + codegen │  (phf::Map statics)  │
└─────────────────┘                   └──────────────────────┘
                                               │
                                               ▼
                                      ┌──────────────────────┐
                                      │  djangofmt_lint      │
                                      │  (constant-time      │
                                      │   lookups at runtime)│
                                      └──────────────────────┘
```

### New Crate: `djangofmt_html_spec`

```
crates/djangofmt_html_spec/
├── Cargo.toml
├── build.rs              # JSON → Rust codegen
├── src/
│   ├── lib.rs            # Re-exports generated statics
│   └── types.rs          # ElementSpec, AttributeSpec, etc.
└── data/
    └── index.json        # Vendored from markuplint (or fetched)
```

---

## Phase 2.1: Data Structures

### `types.rs`

```rust
/// Specification for an HTML element.
#[derive(Debug, Clone)]
pub struct ElementSpec {
    pub name: &'static str,
    pub deprecated: bool,
    pub void_element: bool,
    pub global_attrs: bool,
    pub attributes: &'static [AttributeSpec],
}

/// Specification for an attribute on an element.
#[derive(Debug, Clone)]
pub struct AttributeSpec {
    pub name: &'static str,
    pub deprecated: bool,
    pub required: bool,
    pub value_type: AttributeValueType,
}

/// Type constraint for attribute values.
#[derive(Debug, Clone)]
pub enum AttributeValueType {
    /// Any value allowed
    Any,
    /// Boolean attribute (no value or empty)
    Boolean,
    /// Enumerated values (case-insensitive)
    Enum(&'static [&'static str]),
    /// URL
    Url,
    /// Integer
    Integer,
    /// Other typed values...
}
```

---

## Phase 2.2: Build Script (`build.rs`)

### Dependencies

```toml
[build-dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
quote = "1"
proc-macro2 = "1"
```

### Build Script Logic

```rust
// build.rs
fn main() {
    println!("cargo:rerun-if-changed=data/index.json");

    // 1. Read and parse JSON
    let json = std::fs::read_to_string("data/index.json").unwrap();
    let spec: MarkuplintSpec = serde_json::from_str(&json).unwrap();

    // 2. Transform to our types
    let elements = transform_elements(&spec);
    let global_attrs = transform_global_attrs(&spec);

    // 3. Generate Rust code with phf_codegen
    let code = generate_code(&elements, &global_attrs);

    // 4. Write to OUT_DIR
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_specs.rs");
    std::fs::write(&dest_path, code).unwrap();
}
```

### Generated Output Example

```rust
// generated_specs.rs (auto-generated, do not edit)
use crate::types::*;

pub static ELEMENTS: phf::Map<&'static str, ElementSpec> = phf::phf_map! {
    "form" => ElementSpec {
        name: "form",
        deprecated: false,
        void_element: false,
        global_attrs: true,
        attributes: &[
            AttributeSpec {
                name: "method",
                deprecated: false,
                required: false,
                value_type: AttributeValueType::Enum(&["get", "post", "dialog"]),
            },
            AttributeSpec {
                name: "action",
                deprecated: false,
                required: false,
                value_type: AttributeValueType::Url,
            },
            // ...
        ],
    },
    "input" => ElementSpec { ... },
    // ~120 elements
};

pub static GLOBAL_ATTRS: phf::Map<&'static str, AttributeSpec> = phf::phf_map! {
    "id" => AttributeSpec { ... },
    "class" => AttributeSpec { ... },
    "style" => AttributeSpec { ... },
    // ...
};
```

---

## Phase 2.3: Integration with `djangofmt_lint`

### Dependency

```toml
# crates/djangofmt_lint/Cargo.toml
[dependencies]
djangofmt_html_spec = { path = "../djangofmt_html_spec" }
```

### Generic Attribute Validation Rule

```rust
// rules/invalid_attr_value.rs
use djangofmt_html_spec::{ELEMENTS, GLOBAL_ATTRS, AttributeValueType};

pub fn check(element: &Element<'_>, checker: &mut Checker<'_>) {
    let tag = element.tag_name.to_ascii_lowercase();

    // Look up element spec (O(1) with phf)
    let Some(spec) = ELEMENTS.get(tag.as_str()) else {
        return; // Unknown element, skip or report
    };

    for attr in &element.attrs {
        if let Attribute::Native(NativeAttribute { name, value, .. }) = attr {
            let attr_name = name.to_ascii_lowercase();

            // Find attribute spec (element-specific or global)
            let attr_spec = spec.attributes.iter()
                .find(|a| a.name == attr_name)
                .or_else(|| GLOBAL_ATTRS.get(attr_name.as_str()));

            if let Some(attr_spec) = attr_spec {
                validate_value(attr_spec, value, checker);
            }
        }
    }
}

fn validate_value(spec: &AttributeSpec, value: Option<(&str, usize)>, checker: &mut Checker) {
    let Some((value_str, offset)) = value else { return };

    // Skip interpolation
    if contains_interpolation(value_str) { return }

    match &spec.value_type {
        AttributeValueType::Enum(allowed) => {
            let normalized = value_str.to_ascii_lowercase();
            if !allowed.contains(&normalized.as_str()) {
                checker.report(/* E002: invalid enum value */);
            }
        }
        AttributeValueType::Integer => {
            if value_str.parse::<i64>().is_err() {
                checker.report(/* E003: expected integer */);
            }
        }
        // ... other types
        _ => {}
    }
}
```

---

## Phase 2.4: Replacing Hardcoded Rules

Once the spec is integrated, the current `form_method.rs` rule becomes **obsolete**—it's just a special case of the generic enum validation. We can:

1. Keep it as a specialized rule with better error messages
2. Or remove it and rely on the generic rule

**Recommendation**: Keep specialized rules for common cases (better UX), use generic rule as fallback.

---

## Implementation Order

| Step | Task                                              | Effort |
| ---- | ------------------------------------------------- | ------ |
| 1    | Create `djangofmt_html_spec` crate skeleton       | Small  |
| 2    | Define `types.rs` data structures                 | Small  |
| 3    | Vendor `index.json` from markuplint               | Small  |
| 4    | Write `build.rs` JSON parser (serde structs)      | Medium |
| 5    | Write `build.rs` code generator (phf_codegen)     | Medium |
| 6    | Add `lib.rs` with `include!` for generated code   | Small  |
| 7    | Add `djangofmt_html_spec` dep to `djangofmt_lint` | Small  |
| 8    | Implement generic `invalid_attr_value` rule       | Medium |
| 9    | Add tests for various attribute types             | Medium |
| 10   | (Optional) Add `unknown_attribute` rule           | Small  |
| 11   | (Optional) Add `deprecated_attribute` rule        | Small  |

---

## Decisions (Answered)

| Question              | Decision                                                                          |
| --------------------- | --------------------------------------------------------------------------------- |
| Markuplint version    | Use latest released version (currently `4.16.1` for html-spec)                    |
| Vendoring vs fetching | Fetch at build time from jsdelivr CDN to avoid large files in git                 |
| Scope                 | Parse all attribute types from JSON, but only implement enum validation initially |
| Unknown elements      | Skip silently (web components / custom elements are expected)                     |
| Django-specific       | No Django-specific attributes needed                                              |

---

## Phase 2.5: Alpine.js and HTMX Support

Markuplint has separate parser packages with spec definitions for Alpine.js and HTMX. We can reuse these.

### Data Sources (jsdelivr CDN)

| Package     | URL                                                                         | Format    |
| ----------- | --------------------------------------------------------------------------- | --------- |
| HTML spec   | `https://cdn.jsdelivr.net/npm/@markuplint/html-spec@latest/index.json`      | JSON      |
| HTMX spec   | `https://cdn.jsdelivr.net/npm/@markuplint/htmx-parser@latest/lib/spec.js`   | JS module |
| Alpine spec | `https://cdn.jsdelivr.net/npm/@markuplint/alpine-parser@latest/lib/spec.js` | JS module |

### HTMX Attributes (from spec.js)

HTMX defines global attributes with enum types:

```javascript
'hx-boost': { type: { enum: ['true', 'false'] } },
'hx-swap': { type: { enum: ['innerHTML', 'outerHTML', 'beforebegin', ...] } },
'hx-encoding': { type: { enum: ['multipart/form-data'] } },
'hx-history': { type: { enum: ['false'] } },
// ... ~30 more attributes
```

### Alpine.js Attributes (from spec.js)

Alpine defines element-specific attributes:

```javascript
// On <template>
'x-for': { type: 'NoEmptyAny' },
'x-if': { type: 'NoEmptyAny' },
'x-teleport': { type: 'NoEmptyAny' },

// On <input>, <select>, <textarea>
'x-model': { type: 'NoEmptyAny' },
```

### Build Script Strategy

Since HTMX/Alpine specs are JavaScript modules (not JSON), we have two options:

**Option A: Manual extraction (recommended for now)**

- Extract the relevant attribute definitions manually into a separate JSON file
- Maintain alongside the build script
- Simpler, no JS parsing needed

**Option B: JS parsing at build time**

- Use a JS parser (e.g., `swc` or `tree-sitter`) to extract the spec object
- More complex, but auto-updates

**Recommendation**: Start with Option A. The HTMX/Alpine specs are relatively stable and small (~50 attributes total). We can always add auto-extraction later.

### Updated Crate Structure

```
crates/djangofmt_html_spec/
├── Cargo.toml
├── build.rs                    # Fetches and parses specs
├── src/
│   ├── lib.rs
│   └── types.rs
└── data/
    ├── htmx-attrs.json         # Manually extracted from htmx-parser
    └── alpine-attrs.json       # Manually extracted from alpine-parser
```

### Generated Output (Updated)

```rust
pub static ELEMENTS: phf::Map<&'static str, ElementSpec> = phf::phf_map! { ... };
pub static GLOBAL_ATTRS: phf::Map<&'static str, AttributeSpec> = phf::phf_map! { ... };

// HTMX attributes (all global)
pub static HTMX_ATTRS: phf::Map<&'static str, AttributeSpec> = phf::phf_map! {
    "hx-boost" => AttributeSpec { value_type: Enum(&["true", "false"]), ... },
    "hx-get" => AttributeSpec { value_type: Url, ... },
    // ...
};

// Alpine attributes (element-specific, stored differently)
pub static ALPINE_TEMPLATE_ATTRS: &[AttributeSpec] = &[
    AttributeSpec { name: "x-for", value_type: Any, ... },
    // ...
];
```

---

## Updated Implementation Order

| Step | Task                                                    | Effort |
| ---- | ------------------------------------------------------- | ------ |
| 1    | Create `djangofmt_html_spec` crate skeleton             | Small  |
| 2    | Define `types.rs` data structures                       | Small  |
| 3    | Create `data/htmx-attrs.json` (manual extraction)       | Small  |
| 4    | Create `data/alpine-attrs.json` (manual extraction)     | Small  |
| 5    | Write `build.rs` to fetch html-spec from jsdelivr       | Medium |
| 6    | Write `build.rs` JSON parser (serde structs)            | Medium |
| 7    | Write `build.rs` code generator (phf_codegen)           | Medium |
| 8    | Merge HTMX/Alpine attrs into generated code             | Small  |
| 9    | Add `lib.rs` with `include!` for generated code         | Small  |
| 10   | Add `djangofmt_html_spec` dep to `djangofmt_lint`       | Small  |
| 11   | Implement generic `invalid_attr_value` rule (enum only) | Medium |
| 12   | Add tests for HTML, HTMX, Alpine attributes             | Medium |
