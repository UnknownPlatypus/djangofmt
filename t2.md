# Linting plan

I want to add a new djangofmt_lint crate to implement linting.
I want to do a first minimal implementation which goal is to detect invalid values in method attribute of <form> nodes.
<form method=""> only allow get / post / dialog

I want to:
- create a new crate for this djangofmt_lint
- use miette::Diagnostic to encapsulate the whole lint diagnostic logic
- I want to work directly on top of the ast generated by markup_fmt in /home/thibaut/.cargo/git/checkouts/markup_fmt-18f14530f61d2ae6/fcdb744/markup_fmt/src/lib.rs:49
- I want to take inspiration from the ruff linter visitor pattern https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L2284-L2292

# Diagnostic API
Use https://github.com/zkat/miette

# Ast checking and traversal.
Take inspiration from ruff:
- [`check_ast`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L3290C13-L3290C23)
- [`visit_body`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L2284-L2292)
- [`analyse_suite`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/analyze/suite.rs#L9)
- [`visit_stmt`](https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/src/checkers/ast/mod.rs#L905)

Give me a detailed plan on how to implement this and ask me clarification question if needed.
Add your plan after this line.

---

# Implementation Plan for `djangofmt_lint`

## Overview

Create a new `djangofmt_lint` crate that:
1. Uses `miette::Diagnostic` for error reporting
2. Works on top of `markup_fmt`'s AST (`Root`, `Node`, `Element`, etc.)
3. Implements a visitor pattern (inline in `Checker`, no separate trait)
4. First rule: validate `<form method="">` attribute (only `get`, `post`, `dialog` allowed)
5. CLI: `djangofmt check` command (separate from format)
6. All rules always enabled, errors cause non-zero exit

---

## Required `markup_fmt` Exports

Please expose the following from your `markup_fmt` fork:

```rust
// In markup_fmt/src/lib.rs, add:
pub mod ast;
pub use parser::Parser;
```

The `ast` module contains: `Root`, `Node`, `NodeKind`, `Element`, `Attribute`, `NativeAttribute`, `JinjaBlock`, `JinjaTag`, `JinjaTagOrChildren`, etc.

---

## Phase 1: Crate Setup

### 1.1 Create crate structure
```
crates/djangofmt_lint/
├── Cargo.toml
└── src/
    ├── lib.rs           # Public API: check_ast(), LintDiagnostic
    ├── checker.rs       # Checker struct with visit_* methods
    └── rules/
        ├── mod.rs       # Rule registry
        └── form_method.rs  # E001: invalid form method
```

### 1.2 `Cargo.toml`
```toml
[package]
name = "djangofmt_lint"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true

[dependencies]
markup_fmt = { workspace = true }
miette = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
insta = { workspace = true }
```

---

## Phase 2: Diagnostic System (miette)

### 2.1 `LintDiagnostic` type

```rust
use miette::{Diagnostic, SourceSpan};

#[derive(Debug, Diagnostic, thiserror::Error)]
#[error("{message}")]
#[diagnostic(code(djangofmt::{code}))]
pub struct LintDiagnostic {
    pub code: &'static str,
    pub message: String,
    #[label("{label}")]
    pub span: SourceSpan,
    pub label: String,
    #[help]
    pub help: Option<String>,
}
```

---

## Phase 3: Checker with Inline Visitor

### 3.1 `Checker` struct with `visit_*` methods

```rust
use markup_fmt::ast::{Attribute, Element, JinjaBlock, JinjaTagOrChildren, Node, NodeKind, Root};

pub struct Checker<'a> {
    pub source: &'a str,
    diagnostics: Vec<LintDiagnostic>,
}

impl<'a> Checker<'a> {
    pub fn new(source: &'a str) -> Self {
        Self {
            source,
            diagnostics: Vec::new(),
        }
    }

    pub fn report(&mut self, diagnostic: LintDiagnostic) {
        self.diagnostics.push(diagnostic);
    }

    pub fn into_diagnostics(self) -> Vec<LintDiagnostic> {
        self.diagnostics
    }

    pub fn visit_root(&mut self, root: &Root<'_>) {
        for node in &root.children {
            self.visit_node(node);
        }
    }

    pub fn visit_node(&mut self, node: &Node<'_>) {
        match &node.kind {
            NodeKind::Element(element) => self.visit_element(element),
            NodeKind::JinjaBlock(block) => self.visit_jinja_block(block),
            // Other node types that contain children...
            _ => {}
        }
    }

    pub fn visit_element(&mut self, element: &Element<'_>) {
        // Run element-level rules
        rules::form_method::check(element, self);

        // Recurse into children
        for child in &element.children {
            self.visit_node(child);
        }
    }

    pub fn visit_jinja_block(&mut self, block: &JinjaBlock<'_, Node<'_>>) {
        for item in &block.body {
            if let JinjaTagOrChildren::Children(children) = item {
                for child in children {
                    self.visit_node(child);
                }
            }
        }
    }
}
```

---

## Phase 4: First Rule - Invalid Form Method

### 4.1 Rule: `E001` - Invalid form method

**File:** `src/rules/form_method.rs`

```rust
use markup_fmt::ast::{Attribute, Element, NativeAttribute};
use crate::{Checker, LintDiagnostic};

const VALID_METHODS: &[&str] = &["get", "post", "dialog"];

pub fn check(element: &Element<'_>, checker: &mut Checker<'_>) {
    if !element.tag_name.eq_ignore_ascii_case("form") {
        return;
    }

    for attr in &element.attrs {
        if let Attribute::Native(NativeAttribute { name, value, .. }) = attr {
            if name.eq_ignore_ascii_case("method") {
                if let Some((value_str, offset)) = value {
                    let normalized = value_str.to_ascii_lowercase();
                    if !VALID_METHODS.contains(&normalized.as_str()) {
                        checker.report(LintDiagnostic {
                            code: "E001",
                            message: format!(
                                "Invalid form method '{value_str}'. Expected one of: get, post, dialog"
                            ),
                            span: (*offset, value_str.len()).into(),
                            label: "invalid method".into(),
                            help: Some("Use 'get', 'post', or 'dialog'".into()),
                        });
                    }
                }
            }
        }
    }
}
```

### 4.2 `src/rules/mod.rs`
```rust
pub mod form_method;
```

---

## Phase 5: Public API

### 5.1 `src/lib.rs`

```rust
mod checker;
mod rules;

pub use checker::Checker;

use markup_fmt::ast::Root;
use miette::{Diagnostic, SourceSpan};

#[derive(Debug, Diagnostic, thiserror::Error)]
#[error("{message}")]
#[diagnostic(code(djangofmt::{code}))]
pub struct LintDiagnostic {
    pub code: &'static str,
    pub message: String,
    #[label("{label}")]
    pub span: SourceSpan,
    pub label: String,
    #[help]
    pub help: Option<String>,
}

/// Check the AST for lint errors.
pub fn check_ast(source: &str, ast: &Root<'_>) -> Vec<LintDiagnostic> {
    let mut checker = Checker::new(source);
    checker.visit_root(ast);
    checker.into_diagnostics()
}
```

---

## Phase 6: CLI Integration

### 6.1 Add `djangofmt check` command

In `djangofmt` crate, add a new command handler:

**File:** `src/commands/check.rs`

```rust
use markup_fmt::{Language, Parser};
use djangofmt_lint::{check_ast, LintDiagnostic};
use miette::{NamedSource, Report};

pub fn check(args: CheckArgs) -> Result<ExitStatus> {
    let mut has_errors = false;

    for file in &args.files {
        let source = std::fs::read_to_string(file)?;
        let mut parser = Parser::new(&source, Language::Jinja, vec![]);
        let ast = parser.parse_root()?;

        let diagnostics = check_ast(&source, &ast);

        for diag in diagnostics {
            has_errors = true;
            let report = Report::new(diag)
                .with_source_code(NamedSource::new(file.display().to_string(), source.clone()));
            eprintln!("{report:?}");
        }
    }

    if has_errors {
        Ok(ExitStatus::Failure)
    } else {
        Ok(ExitStatus::Success)
    }
}
```

---

## Phase 7: Tests with `cargo insta`

### 7.1 Snapshot tests

**File:** `crates/djangofmt_lint/tests/rules.rs`

```rust
use djangofmt_lint::check_ast;
use markup_fmt::{Language, Parser};
use insta::assert_yaml_snapshot;

fn check(source: &str) -> Vec<String> {
    let mut parser = Parser::new(source, Language::Jinja, vec![]);
    let ast = parser.parse_root().unwrap();
    check_ast(source, &ast)
        .into_iter()
        .map(|d| format!("{}: {}", d.code, d.message))
        .collect()
}

#[test]
fn test_form_method_valid() {
    assert_yaml_snapshot!(check(r#"<form method="get"></form>"#));
    assert_yaml_snapshot!(check(r#"<form method="post"></form>"#));
    assert_yaml_snapshot!(check(r#"<form method="dialog"></form>"#));
    assert_yaml_snapshot!(check(r#"<form method="GET"></form>"#));
}

#[test]
fn test_form_method_invalid() {
    assert_yaml_snapshot!(check(r#"<form method="put"></form>"#));
    assert_yaml_snapshot!(check(r#"<form method="delete"></form>"#));
    assert_yaml_snapshot!(check(r#"<form method="patch"></form>"#));
}

#[test]
fn test_form_method_nested() {
    assert_yaml_snapshot!(check(r#"
        {% if foo %}
            <form method="invalid"></form>
        {% endif %}
    "#));
}
```

### 7.2 Test directory structure
```
crates/djangofmt_lint/
├── tests/
│   ├── rules.rs
│   └── snapshots/
│       └── (auto-generated by insta)
```

---

## Summary

| Decision | Choice |
|----------|--------|
| AST access | You expose `pub mod ast` + `pub use parser::Parser` |
| Offset semantics | Relative to source string start ✓ |
| Rule config | All rules always enabled |
| CLI command | `djangofmt check` (separate from format) |
| Severity | Errors (non-zero exit code) |
| Visitor pattern | Inline `visit_*` methods in `Checker` |
| Testing | `cargo insta` snapshots |
